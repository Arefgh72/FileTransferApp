# transfer_core/discovery.py - Logic for discovering file transfer servers using UDPimport socketimport timeimport sys # For file=sys.stderr in prints# Import config and utils and helpers using relative imports within the package structureimport config # Assuming config is in the package rootimport utils # Assuming utils is in the package rootfrom .helpers import CancelledError # Import the custom exception# Note: This module contains the UDP listener for the server side# and the UDP broadcaster/listener for the client side discovery.def listen_for_discovery_task(stop_event, gui_callbacks, get_active_server_port_cb):    """    Thread task for the server to listen for UDP discovery broadcast messages and respond.    Args:        stop_event (threading.Event): Event to signal the listener thread to stop.        gui_callbacks (dict): Dictionary of GUI callbacks provided by the GUI.                              Includes general callbacks like update_status, show_error.                              Needs 'root' for safe_gui_update.                              Needs 'is_server_running_cb' to check if the main server is active.        get_active_server_port_cb (callable): Callback function to get the current active server port from the GUI.    """    print("DEBUG: listen_for_discovery_task started")    udp_socket = None    try:        udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)        # Allow reuse of the address and port        udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        # Allow sending broadcast messages        udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)        # Bind to an empty string or "0.0.0.0" to listen on all available network interfaces        # Use the specific discovery port from config        udp_socket.bind(("", config.DISCOVERY_PORT))        # Status update about listening is done by GUI after main server successful bind callback (_set_active_server_port)        print(f"DEBUG: File Transfer Discovery server listening on UDP port {config.DISCOVERY_PORT}")        # Loop continues as long as the stop_event is NOT set        while not stop_event.is_set():            try:                # Set a short timeout for recvfrom() to allow checking the stop_event periodically.                # This makes recvfrom() non-blocking in a way that allows checking the event.                udp_socket.settimeout(config.CANCEL_CHECK_INTERVAL) # Use the same interval as cancel checks                # Wait to receive a broadcast message                message, client_address = udp_socket.recvfrom(1024) # Use a reasonable buffer size for the message                # Decode the received message (ignore errors) and remove leading/trailing whitespace                message = message.decode('utf-8', errors='ignore').strip()                # print(f"DEBUG: Received UDP message from {client_address[0]}: {message}") # Too verbose for regular operation                # Check if the received message is the expected discovery message                if message == config.DISCOVERY_MESSAGE:                    # Respond with server details if the main TCP server is currently running and bound to a port                    # Use the callback to get the currently active TCP server port from the GUI state                    active_server_port = get_active_server_port_cb()                    # Use the callback to check if the main TCP server is actively running (GUI state)                    is_server_running_cb = gui_callbacks.get('is_server_running_cb')                    # Respond only if a valid port is bound AND the GUI state indicates the server is running                    # (The second check prevents responding if the server is in a stopping or failed state but the port variable hasn't been reset yet)                    if active_server_port is not None and (is_server_running_cb is None or is_server_running_cb()):                        print(f"DEBUG: File transfer discovery message from {client_address[0]}. Sending response.")                        # Response format: BASE_RESPONSE|PORT (using the header separator)                        current_response = f"{config.SERVER_RESPONSE_BASE}{config.HEADER_SEPARATOR}{active_server_port}"                        # Send the response back to the client that sent the discovery message                        udp_socket.sendto(current_response.encode('utf-8'), client_address)                    else:                         # Server not running or port not bound yet. Do not respond.                         # print("DEBUG: Cannot respond to discovery, file server not running or port not set.") # Too verbose                         pass            except socket.timeout:                # This exception is raised when recvfrom() times out. This is expected behavior                # because we set a timeout to allow the loop to check the stop_event.                # Just continue the loop to re-check the stop_event.                continue            except Exception as e:                 # Handle other potential errors during receive/sendto operations within the loop.                 # These are typically minor network glitches.                 print(f"DEBUG: Minor error in File Transfer UDP Discovery loop: {e}", file=sys.stderr)                 # Add a small sleep to prevent a busy-waiting loop in case of repeated, non-fatal errors.                 time.sleep(0.1)    except OSError as e:        # Catch errors that occur when trying to create or bind the UDP socket.        # These are often critical for the discovery listener (e.g., address already in use, permission denied).        print(f"DEBUG: OSError starting File Transfer discovery server: {e}", file=sys.stderr)        # Provide specific error messages based on common errno values        if e.errno in (98, 10048): # EADDRINUSE (Linux/macOS), WSAEADDRINUSE (Windows)             error_msg = f"[!] خطا: پورت UDP {config.DISCOVERY_PORT} (کشف سرور فایل) در حال استفاده است. برنامه دیگر از این پورت استفاده می‌کند؟"        elif e.errno == 10013: # WSAEACCES (Windows) - Permission denied by firewall             error_msg = f"[!] خطا: دسترسی به پورت UDP {config.DISCOVERY_PORT} (کشف سرور فایل) مسدود شده است (فایروال؟). لطفاً دسترسی را مجاز کنید."        else:            error_msg = f"[!] خطای مرگبار در شنونده کشف سرور فایل UDP: {e}"        # Only show this critical error message if the main server is still intended to be running.        # The main server thread might have already failed or been stopped, making this UDP error less critical in that context.        is_server_running_cb = gui_callbacks.get('is_server_running_cb')        if is_server_running_cb is None or is_server_running_cb(): # Check if callback exists and returns True             # Use safe_gui_update to show the error message in the GUI             utils.safe_gui_update(gui_callbacks['root'], utils._update_status_direct, gui_callbacks['status_area'], error_msg)             utils.safe_gui_update(gui_callbacks['root'], utils._show_messagebox_direct, 'error', "خطای شنونده کشف سرور فایل", error_msg + "\nلطفا برنامه را ری‌استارت کنید.")        # Signal the stop_event to ensure cleanup happens and the thread exits.        stop_event.set()    except Exception as e:        # Catch any other uncaught exceptions in the discovery server thread.        print(f"DEBUG: Uncaught Exception in File Transfer discovery server: {e}", file=sys.stderr)        error_msg = f"[!] خطای مرگبار ناشناخته در شنونده کشف سرور فایل UDP: {e}"        # Only show this error message if the main server is still intended to be running.        is_server_running_cb = gui_callbacks.get('is_server_running_cb')        if is_server_running_cb is None or is_server_running_cb():             # Use safe_gui_update to show the error message in the GUI             utils.safe_gui_update(gui_callbacks['root'], utils._update_status_direct, gui_callbacks['status_area'], error_msg)             utils.safe_gui_update(gui_callbacks['root'], utils._show_messagebox_direct, 'error', "خطای شنونده کشف سرور فایل", f"خطای ناشناخته شنونده کشف سرور فایل UDP:\n{e}\nلطفا برنامه را ری‌استارت کنید.")        # Signal the stop_event to ensure cleanup happens and the thread exits.        stop_event.set()    finally:        # This block runs when the listen_for_discovery_task thread is stopping.        print("DEBUG: listen_for_discovery_task finally block entered")        # Ensure the UDP socket is closed gracefully if it was created.        if udp_socket:            try:                udp_socket.close()            except Exception as e:                 # Log error during close but don't stop the cleanup                 print(f"DEBUG: Error closing File Transfer Discovery socket in finally: {e}", file=sys.stderr)            print("DEBUG: File Transfer Discovery socket closed")        # Status update about stopping might be redundant if GUI is already closing,        # but it's good practice to signal the state change.        # utils.safe_gui_update(gui_callbacks['root'], utils._update_status_direct, gui_callbacks['status_area'], "[-] ترد شنونده کشف سرور فایل متوقف شد.")        print("DEBUG: listen_for_discovery_task finished")def discover_file_server_task(gui_callbacks, cancel_transfer_event):    """    Thread task for the client to discover available file servers using UDP broadcast.    This task is run by the client when initiating a transfer.    It broadcasts a discovery message and waits for a server response.    It returns the server info (IP, Port) tuple if found within the timeout, or None otherwise.    It handles its own GUI status updates and checks the cancel_transfer_event.    Args:        gui_callbacks (dict): Dictionary of GUI callbacks provided by the GUI.                              Includes general callbacks like update_status, show_warning, show_error, update_speed.                              Needs 'root' for safe_gui_update.        cancel_transfer_event (threading.Event): Event to check for cancellation by the user.    Returns:        tuple or None: (server_ip, server_port) if a server is found, otherwise None.    """    print("DEBUG: discover_file_server_task started")    udp_socket = None    found_server_info = None # (ip, port) tuple if found    try:        # Update GUI status to indicate discovery is starting        utils.safe_gui_update(gui_callbacks['root'], gui_callbacks['update_status'], f"[*] در حال جستجو برای سرور فایل در شبکه روی UDP پورت {config.DISCOVERY_PORT}...")        utils.safe_gui_update(gui_callbacks['root'], gui_callbacks['update_speed'], "Speed: Discovering Server...")        print(f"DEBUG: Broadcasting discovery message on UDP port {config.DISCOVERY_PORT}")        # Create a UDP socket        udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)        # Allow broadcasting from this socket        udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)        # Set a short receive timeout initially to avoid blocking forever if send fails        udp_socket.settimeout(config.CANCEL_CHECK_INTERVAL * 5) # Give send a bit more time        # Prepare the discovery message bytes        message = config.DISCOVERY_MESSAGE.encode('utf-8')        try:            # Send the broadcast message to the discovery port on the broadcast address (255.255.255.255 is standard)            # This sends the message to all devices on the local network segment.            udp_socket.sendto(message, ('255.255.255.255', config.DISCOVERY_PORT))            print("DEBUG: Discovery broadcast message sent.")        except Exception as e:            # If sending fails, raise an exception to be caught by the outer try/except.            raise Exception(f"Error sending discovery broadcast: {e}")        # Wait for a server response        # Use a loop that checks for the cancel event and also respects an overall timeout for discovery.        start_discover_time = time.time()        # Set the socket timeout for receiving response within the loop.        # It should be short to allow frequent checks of the cancel_transfer_event.        udp_socket.settimeout(config.CANCEL_CHECK_INTERVAL)        # Loop continues until stop_event is set OR overall timeout is reached OR a server is found        while not cancel_transfer_event.is_set() and (time.time() - start_discover_time) < config.DISCOVERY_TIMEOUT:             try:                  # Wait to receive a response message                  response, server_address = udp_socket.recvfrom(1024) # Use a reasonable buffer size for the response                  # Decode the received response message and remove whitespace                  response = response.decode('utf-8', errors='ignore').strip()                  print(f"DEBUG: Received UDP response from {server_address[0]}: {response}")                  # Check if the response starts with the expected base response string                  # Expected format: SERVER_RESPONSE_BASE|PORT (using the header separator)                  parts = response.split(config.HEADER_SEPARATOR)                  # Check if response has at least two parts and the first part matches the base response                  if len(parts) == 2 and parts[0] == config.SERVER_RESPONSE_BASE:                       try:                           # Try to parse the second part as the server's TCP port                           server_port = int(parts[1])                           # Found a valid server response! Store its IP and port.                           found_server_info = (server_address[0], server_port)                           # Update GUI status to indicate a server was found                           utils.safe_gui_update(gui_callbacks['root'], gui_callbacks['update_status'], f"[+] سرور فایل پیدا شد در {server_address[0]}:{server_port}")                           print(f"DEBUG: File server found: {found_server_info}")                           break # Exit the response waiting loop (server found)                       except ValueError:                           # If the second part is not a valid integer port number, log a warning and continue listening for other responses.                           print(f"DEBUG: Invalid port number in discovery response from {server_address[0]}: {parts[1]}", file=sys.stderr)                           continue # Continue the while loop to listen for other potential responses                  else:                       # If the response format is not as expected, log a warning and continue listening.                       print(f"DEBUG: Malformed discovery response from {server_address[0]}: {response}", file=sys.stderr)                       continue # Continue the while loop to listen for other potential responses             except socket.timeout:                 # This exception is raised when recvfrom() times out. This is expected behavior                 # due to the short timeout set to allow checking the cancel_transfer_event.                 # Just continue the while loop to re-check the cancel event and the overall timeout.                 continue             except Exception as e:                 # Handle any other errors during receive operation within the loop.                 # Log a warning and continue listening unless it's a fatal socket error that breaks the loop implicitly.                 print(f"DEBUG: Error during UDP discovery response receive: {e}", file=sys.stderr)                 # Add a small sleep to prevent a very tight loop if errors occur repeatedly.                 time.sleep(0.05)        # After the while loop finishes, check why it exited:        # 1. cancel_transfer_event was set: found_server_info will be None (set below).        # 2. Overall timeout reached: found_server_info will be None.        # 3. Server found: found_server_info will contain the server details.        # If loop exited because of the overall timeout and no server was found, AND the operation was NOT cancelled by the user:        if not cancel_transfer_event.is_set() and found_server_info is None:             # Report to GUI that discovery timed out without finding a server.             utils.safe_gui_update(gui_callbacks['root'], gui_callbacks['update_status'], "[*] جستجوی سرور انتقال فایل به پایان رسید اما سروری پیدا نشد.")             utils.safe_gui_update(gui_callbacks['root'], gui_callbacks['show_warning'], "سرور یافت نشد", f"سرور فایلی در شبکه پیدا نشد ({config.DISCOVERY_TIMEOUT} ثانیه زمان انتظار). لطفا مطمئن شوید برنامه در حالت دریافت روی کامپیوتر دیگر در حال اجرا است و فایروال اجازه ارتباط UDP و TCP را می‌دهد.")             print("DEBUG: No file server found within timeout.")        # If the operation was cancelled by the user, explicitly ensure found_server_info is None        # (This is already true if cancel_transfer_event.is_set() was checked at the start of the loop and it exited immediately,        # but explicit None assignment is safer).        if cancel_transfer_event.is_set():             found_server_info = None             # A status message for cancellation is handled by the caller task (send_file_task/send_folder_task)             # after discover_file_server_task returns None.    except OSError as e:         # Catch errors that occur when trying to create or send from the UDP socket (outside the receive loop).         # These are often critical errors like permission denied by firewall or network interface issues.         print(f"DEBUG: OSError during discovery broadcast: {e}", file=sys.stderr)         if e.errno == 10013: # WSAEACCES (Windows) - Permission denied             error_msg = f"[!] خطا: دسترسی به پورت UDP {config.DISCOVERY_PORT} برای ارسال پیام کشف سرور مسدود شده است (فایروال؟). لطفاً دسترسی را مجاز کنید."         else:             error_msg = f"[!] خطای OSError در حین کشف سرور فایل: {e}"         # Report the error to the GUI         utils.safe_gui_update(gui_callbacks['root'], gui_callbacks['update_status'], error_msg)         utils.safe_gui_update(gui_callbacks['root'], gui_callbacks['show_error'], "خطای کشف سرور", error_msg)         # Set found_server_info to None on error as discovery failed critically         found_server_info = None    except Exception as e:        # Catch any other uncaught exceptions during the discovery process.        print(f"DEBUG: Uncaught Exception during file server discovery: {e}", file=sys.stderr)        error_msg = f"[!] خطای ناشناخته در حین کشف سرور فایل: {e}"        # Report the error to the GUI        utils.safe_gui_update(gui_callbacks['root'], gui_callbacks['update_status'], error_msg)        utils.safe_gui_update(gui_callbacks['root'], gui_callbacks['show_error'], "خطای کشف سرور", f"خطای ناشناخته کشف سرور:\n{e}")        # Set found_server_info to None on critical error        found_server_info = None    finally:        # This block runs when the discover_file_server_task thread is finished (either successfully, cancelled, or due to error).        print("DEBUG: discover_file_server_task finally block entered")        # Ensure the UDP socket is closed gracefully if it was created.        if udp_socket:            try:                udp_socket.close()            except Exception as e:                 # Log error during close but don't stop the cleanup                 print(f"DEBUG: Error closing File Transfer Discovery socket in finally: {e}", file=sys.stderr)            print("DEBUG: File Transfer Discovery socket closed")        # Return the found server info (or None) back to the caller task (send_file_task/send_folder_task).        return found_server_info